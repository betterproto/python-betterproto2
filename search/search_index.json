{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to betterproto2's documentation!</p> <p>betterproto is a protobuf compiler and interpreter. It improves the experience of using Protobuf and gRPC in Python, by generating readable, understandable, and idiomatic Python code, using modern language features.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Generated messages are both binary &amp; JSON serializable</li> <li>Messages use relevant python types, e.g. <code>Enum</code>, <code>datetime</code> and <code>timedelta</code> objects</li> <li><code>async</code>/<code>await</code> support for gRPC Clients and Servers</li> <li>Generates modern, readable, idiomatic python code</li> </ul>"},{"location":"api/","title":"API reference","text":"<p>The following document outlines betterproto's api. These classes should not be extended manually.</p>"},{"location":"api/#message","title":"Message","text":"<p>               Bases: <code>ABC</code></p> <p>The base class for protobuf messages, all generated messages will inherit from it. This class registers the message fields which are used by the serializers and parsers to go between the Python, binary and JSON representations of the message.</p> <p>Return the name and value of a message's one-of field group.</p>"},{"location":"api/#betterproto2.Message.FromString","title":"<code>FromString(s)</code>  <code>classmethod</code>","text":"<p>Parse the binary encoded Protobuf into this message instance. This returns the instance itself and is therefore assignable and chainable.</p> <p>.. note::     This is a method for compatibility with other libraries,     you should really use :meth:<code>parse</code>.</p>"},{"location":"api/#betterproto2.Message.FromString--parameters","title":"Parameters","text":"<p>data: :class:<code>bytes</code>     The data to parse the protobuf from.</p>"},{"location":"api/#betterproto2.Message.FromString--returns","title":"Returns","text":"<p>:class:<code>Message</code>     The initialized message.</p>"},{"location":"api/#betterproto2.Message.SerializeToString","title":"<code>SerializeToString()</code>","text":"<p>Get the binary encoded Protobuf representation of this message instance.</p> <p>.. note::     This is a method for compatibility with other libraries,     you should really use <code>bytes(x)</code>.</p>"},{"location":"api/#betterproto2.Message.SerializeToString--returns","title":"Returns","text":"<p>:class:<code>bytes</code>     The binary encoded Protobuf representation of this message instance</p>"},{"location":"api/#betterproto2.Message.__bool__","title":"<code>__bool__()</code>","text":"<p>True if the message has any fields with non-default values.</p>"},{"location":"api/#betterproto2.Message.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Get the binary encoded Protobuf representation of this message instance.</p>"},{"location":"api/#betterproto2.Message.dump","title":"<code>dump(stream, delimit=False)</code>","text":"<p>Dumps the binary encoded Protobuf message to the stream.</p>"},{"location":"api/#betterproto2.Message.dump--parameters","title":"Parameters","text":"<p>stream: :class:<code>BinaryIO</code>     The stream to dump the message to. delimit:     Whether to prefix the message with a varint declaring its size.     TODO is it actually needed?</p>"},{"location":"api/#betterproto2.Message.from_dict","title":"<code>from_dict(value, *, ignore_unknown_fields=False)</code>  <code>classmethod</code>","text":"<p>Parse the key/value pairs into the a new message instance.</p>"},{"location":"api/#betterproto2.Message.from_dict--parameters","title":"Parameters","text":"<p>value: Dict[:class:<code>str</code>, Any]     The dictionary to parse from.</p>"},{"location":"api/#betterproto2.Message.from_dict--returns","title":"Returns","text":"<p>:class:<code>Message</code>     The initialized message.</p>"},{"location":"api/#betterproto2.Message.from_json","title":"<code>from_json(value, *, ignore_unknown_fields=False)</code>  <code>classmethod</code>","text":"<p>A helper function to return the message instance from its JSON representation. This returns the instance itself and is therefore assignable and chainable.</p> <p>This is equivalent to::</p> <pre><code>return message.from_dict(json.loads(value))\n</code></pre>"},{"location":"api/#betterproto2.Message.from_json--parameters","title":"Parameters","text":"<p>value: Union[:class:<code>str</code>, :class:<code>bytes</code>]     The value to pass to :func:<code>json.loads</code>.</p>"},{"location":"api/#betterproto2.Message.from_json--returns","title":"Returns","text":"<p>:class:<code>Message</code>     The initialized message.</p>"},{"location":"api/#betterproto2.Message.is_set","title":"<code>is_set(name)</code>","text":"<p>Check if field with the given name has been set.</p>"},{"location":"api/#betterproto2.Message.is_set--parameters","title":"Parameters","text":"<p>name: :class:<code>str</code>     The name of the field to check for.</p>"},{"location":"api/#betterproto2.Message.is_set--returns","title":"Returns","text":"<p>:class:<code>bool</code> <code>True</code> if field has been set, otherwise <code>False</code>.</p>"},{"location":"api/#betterproto2.Message.load","title":"<code>load(stream, size=None)</code>","text":"<p>Load the binary encoded Protobuf from a stream into this message instance. This returns the instance itself and is therefore assignable and chainable.</p>"},{"location":"api/#betterproto2.Message.load--parameters","title":"Parameters","text":"<p>stream: :class:<code>bytes</code>     The stream to load the message from. size: :class:<code>Optional[int]</code>     The size of the message in the stream.     Reads stream until EOF if <code>None</code> is given.     Reads based on a size delimiter prefix varint if SIZE_DELIMITED is given.</p>"},{"location":"api/#betterproto2.Message.load--returns","title":"Returns","text":"<p>:class:<code>Message</code>     The initialized message.</p>"},{"location":"api/#betterproto2.Message.parse","title":"<code>parse(data)</code>  <code>classmethod</code>","text":"<p>Parse the binary encoded Protobuf into this message instance. This returns the instance itself and is therefore assignable and chainable.</p>"},{"location":"api/#betterproto2.Message.parse--parameters","title":"Parameters","text":"<p>data: :class:<code>bytes</code>     The data to parse the message from.</p>"},{"location":"api/#betterproto2.Message.parse--returns","title":"Returns","text":"<p>:class:<code>Message</code>     The initialized message.</p>"},{"location":"api/#betterproto2.Message.to_dict","title":"<code>to_dict(*, output_format=OutputFormat.PROTO_JSON, casing=Casing.CAMEL, include_default_values=False)</code>","text":"<p>Return a dict representation of the message.</p>"},{"location":"api/#betterproto2.Message.to_dict--parameters","title":"Parameters","text":"<p>casing: :class:<code>Casing</code>     The casing to use for key values. Default is :attr:<code>Casing.CAMEL</code> for     compatibility purposes. include_default_values: :class:<code>bool</code>     If <code>True</code> will include the default values of fields. Default is <code>False</code>.     E.g. an <code>int32</code> field will be included with a value of <code>0</code> if this is     set to <code>True</code>, otherwise this would be ignored.</p>"},{"location":"api/#betterproto2.Message.to_dict--returns","title":"Returns","text":"<p>Dict[:class:<code>str</code>, Any]     The JSON serializable dict representation of this object.</p>"},{"location":"api/#betterproto2.Message.to_json","title":"<code>to_json(indent=None, include_default_values=False, casing=Casing.CAMEL)</code>","text":"<p>A helper function to parse the message instance into its JSON representation.</p> <p>This is equivalent to::</p> <pre><code>json.dumps(message.to_dict(), indent=indent)\n</code></pre>"},{"location":"api/#betterproto2.Message.to_json--parameters","title":"Parameters","text":"<p>indent: Optional[Union[:class:<code>int</code>, :class:<code>str</code>]]     The indent to pass to :func:<code>json.dumps</code>.</p> :class:<code>bool</code> <p>If <code>True</code> will include the default values of fields. Default is <code>False</code>. E.g. an <code>int32</code> field will be included with a value of <code>0</code> if this is set to <code>True</code>, otherwise this would be ignored.</p> :class:<code>Casing</code> <p>The casing to use for key values. Default is :attr:<code>Casing.CAMEL</code> for compatibility purposes.</p>"},{"location":"api/#betterproto2.Message.to_json--returns","title":"Returns","text":"<p>:class:<code>str</code>     The JSON representation of the message.</p>"},{"location":"api/#betterproto2.which_one_of--returns","title":"Returns","text":"<p>Tuple[:class:<code>str</code>, Any]     The field name and the value for that field.</p>"},{"location":"api/#enumerations","title":"Enumerations","text":"<p>               Bases: <code>IntEnum</code></p> <p>               Bases: <code>Enum</code></p> <p>Casing constants for serialization.</p>"},{"location":"api/#betterproto2.Enum.from_string","title":"<code>from_string(name)</code>  <code>classmethod</code>","text":"<p>Return the value which corresponds to the string name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the enum member to get.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>The member was not found in the Enum.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The corresponding value</p>"},{"location":"api/#betterproto2.Casing.__call__","title":"<code>__call__(name)</code>","text":"<p>Convert the given name to the casing style.</p>"},{"location":"descriptors/","title":"Google Protobuf Descriptors","text":"<p>Google's protoc plugin for Python generated DESCRIPTOR fields that enable reflection capabilities in many libraries (e.g. grpc, grpclib, mcap).</p> <p>By default, betterproto2 doesn't generate these as it introduces a dependency on <code>protobuf</code>. If you're okay with this dependency and want to generate DESCRIPTORs, use the compiler option <code>python_betterproto2_opt=google_protobuf_descriptors</code>.</p>"},{"location":"descriptors/#grpclib-reflection","title":"grpclib Reflection","text":"<p>In order to properly use reflection right now, you will need to modify the <code>DescriptorPool</code> that is used by grpclib's <code>ServerReflection</code>. To do so, take a look at the use of <code>ServerReflection.extend</code> in the <code>test_grpclib_reflection</code> test in https://github.com/vmagamedov/grpclib/blob/master/tests/grpc/test_grpclib_reflection.py  In the future, once https://github.com/vmagamedov/grpclib/pull/204 is merged, you will be able to pass the <code>default_google_proto_descriptor_pool</code> into the <code>ServerReflection.extend</code> class method.</p>"},{"location":"development/","title":"Development","text":"<p>This page targets the betterproto maintainers.</p>"},{"location":"development/#recompiling-the-lib-proto-files","title":"Recompiling the lib proto files","text":"<p>After some updates in the compiler, it might be useful to recompile the standard Google proto files used by the compiler. The output of the <code>compiler_lib</code> test should be used.</p> <p>Warning</p> <p>These proto files are written with the <code>proto2</code> syntax, which is not supported by betterproto. For the compiler to work, you need to manually patch the generated file to mark the field <code>oneof_index</code> in <code>Field</code> and <code>FieldDescriptorProto</code> optional.</p> <p>In the compiler, you also need to compile the plugin.proto file in <code>src/betterproto2_compiler/lib/google.protobug/compiler/__init__.py</code>.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#compilation","title":"Compilation","text":""},{"location":"getting-started/#install-protoc","title":"Install protoc","text":"<p>The betterproto2 compiler is a plugin of <code>protoc</code>, you first need to install it.</p> <p>You can also use it from <code>grpcio-tools</code>:</p> <pre><code>pip install grpcio-tools\n</code></pre>"},{"location":"getting-started/#install-betterproto2_compiler","title":"Install <code>betterproto2_compiler</code>","text":"<p>It is possible to install <code>betterproto2_compiler</code> using pip:</p> <pre><code>pip install betterproto2_compiler\n</code></pre>"},{"location":"getting-started/#compile-a-proto-file","title":"Compile a proto file","text":"<p>Create the following <code>example.proto</code> file.</p> <pre><code>syntax = \"proto3\";\n\npackage helloworld;\n\nmessage HelloWorld {\n    string message = 1;\n}\n\nservice HelloService {\n    rpc SayHello (HelloWorld) returns (HelloWorld);\n}\n</code></pre> <p>You should be able to compile it using:</p> <pre><code>mkdir lib\nprotoc -I . --python_betterproto2_out=lib example.proto\n</code></pre> <p>If you installed <code>protoc</code> with <code>grpc-tools</code>, the command will be:</p> <pre><code>mkdir lib\npython -m grpc.tools.protoc -I . --python_betterproto2_out=lib example.proto\n</code></pre>"},{"location":"getting-started/#service-compilation","title":"Service compilation","text":""},{"location":"getting-started/#clients","title":"Clients","text":"<p>By default, for each service, betterproto will generate a synchronous client. Both synchronous and asynchronous clients are supported.</p> <ul> <li>Synchronous clients rely on the <code>grpcio</code> package. Make sure to enable the <code>grpcio</code> extra package when installing     betterproto2 to use them.</li> <li>Asynchronous clients rely on the <code>grpclib</code> package. Make sure to enable the <code>grpclib</code> extra package when installing     betterproto2 to use them.</li> </ul> <p>To choose which clients to generate, use the <code>client_generation</code> option of betterproto. It supports the following values:</p> <ul> <li><code>none</code>: Clients are not generated.</li> <li><code>sync</code>: Only synchronous clients are generated.</li> <li><code>async</code>: Only asynchronous clients are generated.</li> <li><code>sync_async</code>: Both synchronous and asynchronous clients are generated.         Asynchronous clients are generated with the Async suffix.</li> <li><code>async_sync</code>: Both synchronous and asynchronous clients are generated.         Synchronous clients are generated with the Sync suffix.</li> <li><code>sync_async_no_default</code>: Both synchronous and asynchronous clients are generated.         Synchronous clients are generated with the Sync suffix, and asynchronous clients are generated with the Async         suffix.</li> </ul> <p>For example, <code>protoc -I . --python_betterproto2_out=lib example.proto --python_betterproto2_opt=client_generation=async</code> will only generate asynchronous clients.</p>"},{"location":"getting-started/#servers","title":"Servers","text":"<p>By default, betterproto will not generate server base classes. To enable them, set the <code>server_generation</code> option to <code>async</code> with <code>--python_betterproto2_opt=server_generation=async</code>.</p> <p>These base classes will be asynchronous and rely on <code>grpclib</code>. To use them, make sure to install <code>betterproto2</code> with the <code>grpclib</code> extra package.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>The package <code>betterproto2</code> can be installed from PyPI using <code>pip</code>:</p> <pre><code>pip install betterproto2[all]\n</code></pre> <p>Warning</p> <p>Make sure that the proto files were generated with a version of <code>betterproto2_compiler</code> that is compatible with your version of <code>betterproto2</code>.</p> <p>The version <code>0.x.y</code> of <code>betterproto</code> is compatible with the version <code>0.a.b</code> of the compiler if and only if <code>a=b</code>.</p>"},{"location":"getting-started/#basic-usage","title":"Basic usage","text":"<p>If you successfuly compiled the <code>example.proto</code> file from the compiler documentation, you should now be able to use it!</p> <pre><code>&gt;&gt;&gt; from lib.helloworld import HelloWorld\n&gt;&gt;&gt; msg = HelloWorld(message=\"Hello world!\")\n&gt;&gt;&gt; msg\nHelloWorld(message='Hello world!')\n&gt;&gt;&gt; bytes(msg)\nb'\\n\\x0cHello world!'\n&gt;&gt;&gt; msg.to_dict()\n{'message': 'Hello world!'}\n</code></pre> <p>Warning</p> <p>The rest of the documentation is not up to date.</p>"},{"location":"getting-started/#async-grpc-support","title":"Async gRPC Support","text":"<p>The generated code includes grpclib based stub (client and server) classes for rpc services declared in the input proto files. It is enabled by default.</p> <p>Given a service definition similar to the one below:</p> <pre><code>syntax = \"proto3\";\n\npackage echo;\n\nmessage EchoRequest {\n    string value = 1;\n    // Number of extra times to echo\n    uint32 extra_times = 2;\n}\n\nmessage EchoResponse {\n    repeated string values = 1;\n}\n\nmessage EchoStreamResponse  {\n    string value = 1;\n}\n\nservice Echo {\n    rpc Echo(EchoRequest) returns (EchoResponse);\n    rpc EchoStream(EchoRequest) returns (stream EchoStreamResponse);\n}\n</code></pre> <p>The generated client can be used like so:</p> <pre><code>import asyncio\nfrom grpclib.client import Channel\nimport echo\n\n\nasync def main():\n    channel = Channel(host=\"127.0.0.1\", port=50051)\n    service = echo.EchoStub(channel)\n    response = await service.echo(value=\"hello\", extra_times=1)\n    print(response)\n\n    async for response in service.echo_stream(value=\"hello\", extra_times=1):\n        print(response)\n\n    # don't forget to close the channel when you're done!\n    channel.close()\n\nasyncio.run(main())\n\n# outputs\nEchoResponse(values=['hello', 'hello'])\nEchoStreamResponse(value='hello')\nEchoStreamResponse(value='hello')\n</code></pre> <p>The server-facing stubs can be used to implement a Python gRPC server. To use them, simply subclass the base class in the generated files and override the service methods:</p> <pre><code>from echo import EchoBase\nfrom grpclib.server import Server\nfrom typing import AsyncIterator\n\n\nclass EchoService(EchoBase):\n    async def echo(self, value: str, extra_times: int) -&gt; \"EchoResponse\":\n        return value\n\n    async def echo_stream(\n        self, value: str, extra_times: int\n    ) -&gt; AsyncIterator[\"EchoStreamResponse\"]:\n        for _ in range(extra_times):\n            yield value\n\n\nasync def start_server():\n    HOST = \"127.0.0.1\"\n    PORT = 1337\n    server = Server([EchoService()])\n    await server.start(HOST, PORT)\n    await server.serve_forever()\n</code></pre>"},{"location":"getting-started/#json","title":"JSON","text":"<p>Message objects include <code>betterproto.Message.to_json</code> and <code>betterproto.Message.from_json</code> methods for JSON (de)serialisation, and <code>betterproto.Message.to_dict</code>, <code>betterproto.Message.from_dict</code> for converting back and forth from JSON serializable dicts.</p> <p>For compatibility the default is to convert field names to <code>betterproto.Casing.CAMEL</code>. You can control this behavior by passing a different casing value, e.g:</p> <pre><code>@dataclass\nclass MyMessage(betterproto.Message):\n    a_long_field_name: str = betterproto.string_field(1)\n\n\n&gt;&gt;&gt; test = MyMessage(a_long_field_name=\"Hello World!\")\n&gt;&gt;&gt; test.to_dict(betterproto.Casing.SNAKE)\n{\"a_long_field_name\": \"Hello World!\"}\n&gt;&gt;&gt; test.to_dict(betterproto.Casing.CAMEL)\n{\"aLongFieldName\": \"Hello World!\"}\n\n&gt;&gt;&gt; test.to_json(indent=2)\n'{\\n  \"aLongFieldName\": \"Hello World!\"\\n}'\n\n&gt;&gt;&gt; test.from_dict({\"aLongFieldName\": \"Goodbye World!\"})\n&gt;&gt;&gt; test.a_long_field_name\n\"Goodbye World!\"\n</code></pre>"},{"location":"tutorial/clients/","title":"Clients","text":"<p>Warning</p> <p>Make sure to enable client generation when compiling your code. See [TODO link]</p>"},{"location":"tutorial/clients/#synchronous-clients","title":"Synchronous clients","text":"<p>Compile the following proto file in a directory called <code>example</code>, with the generation of synchronous clients activated.</p> <pre><code>syntax = \"proto3\";\n\nmessage Request {}\nmessage Response {}\n\nservice MyService {\n    rpc MyRPC(Request) returns (Response);\n}\n</code></pre> <p>The synchronous client can be used as follows:</p> <pre><code>import grpc\n\nfrom example import Request, MyServiceStub\n\nwith grpc.insecure_channel(\"address:port\") as channel:\n    client = MyServiceStub(channel)\n\n    response = client.my_rpc(Request())\n</code></pre>"},{"location":"tutorial/clients/#asynchronous-clients","title":"Asynchronous clients","text":""},{"location":"tutorial/clients/#with-grpcio","title":"With grpcio","text":"<p>Warning</p> <p>No yet supported</p>"},{"location":"tutorial/clients/#with-grpclib","title":"With grpclib","text":"<p>Warning</p> <p>Documentation not yet available</p>"},{"location":"tutorial/messages/","title":"Messages","text":"<p>A protobuf message is represented by a class that inherit from the <code>betterproto2.Message</code> abstract class.</p>"},{"location":"tutorial/messages/#field-presence","title":"Field presence","text":"<p>The documentation of protobuf defines field presence as \"the notion of whether a protobuf field has a value\". The presence of a field can be tracked in two ways:</p> <ul> <li>Implicit presence. It is not possible to know if the field was set to its default value or if it was simply    omitted. When the field is omitted, it is set to its default value automatically (<code>0</code> for an <code>int</code>, <code>\"\"</code> for a    string, ...)</li> <li>Explicit presence. It is possible to know if the field was set to its default value or if it was    omitted. In Python, these fields are marked as optional. They are set to <code>None</code> when omitted.</li> </ul> <p>The documentation of protobuf shows when field presence is explicitly tracked.</p> <p>For example, given the following <code>proto</code> file:</p> <pre><code>syntax = \"proto3\";\n\nmessage Message {\n    int32 x = 1;\n    optional int32 y = 2;\n}\n</code></pre> <p>We can see that the default values are not the same:</p> <pre><code>&gt;&gt;&gt; msg = Message()\n&gt;&gt;&gt; print(msg.x)\n0\n&gt;&gt;&gt; print(msg.y)\nNone\n</code></pre> <p>Warning</p> <p>When a field is a message, its presence is always tracked explicitly even if it is not marked as optional. Marking a message field as optional has no effect: the default value of such a field is always <code>None</code>, not an empty message.</p>"},{"location":"tutorial/messages/#oneof-support","title":"Oneof support","text":"<p>Protobuf supports grouping fields in a <code>oneof</code> clause: at most one of the fields in the group can be set at the same time. Let's use the following <code>proto</code>:</p> <pre><code>syntax = \"proto3\";\n\nmessage Test {\n    oneof group {\n        bool a = 1;\n        int32 b = 2;\n        string c = 3;\n    }\n}\n</code></pre> <p>The <code>betterproto2.which_one_of</code> function allows finding which one of the fields of the <code>oneof</code> group is set. The function returns the name of the field that is set, and the value of the field.</p> <pre><code>&gt;&gt;&gt; betterproto2.which_one_of(Message(a=True), group_name=\"group\")\n('a', True)\n&gt;&gt;&gt; betterproto2.which_one_of(Message(), group_name=\"group\")\n('', None)\n</code></pre> <p>On Python 3.10 and later, it is also possible to use a <code>match</code> statement to find which item in a <code>oneof</code> group is active.</p> <pre><code>&gt;&gt;&gt; def find(m: Message) -&gt; str:\n...     match m:\n...         case Message(a=bool(value)):\n...             return f\"a is set to {value}\"\n...         case Message(b=int(value)):\n...             return f\"b is set to {value}\"\n...     return \"No field set\"\n...\n&gt;&gt;&gt; find(Message(a=True))\n'a is set to True'\n&gt;&gt;&gt; find(Message(b=12))\n'b is set to 12'\n&gt;&gt;&gt; find(Message())\n'No field set'\n</code></pre>"},{"location":"tutorial/messages/#unwrapping-optional-values","title":"Unwrapping optional values","text":"<p>In protobuf, fields are often marked as optional, either manually or because it is the default behavior of the protocol. If you care about type-checking, this can be tedious to handle as you need to make sure each field is not <code>None</code> before using, even when you know that the field will never be <code>None</code> is your application.</p> <pre><code># typing error: item \"None\" of \"Message | None\" has no attribute \"field\"\nmessage.msg_field.field\n</code></pre> <p>To simplify this, betterproto provides a convenience function: <code>unwrap</code>. This function takes an optional value, and returns the same value if it is not <code>None</code>. If the value is <code>None</code>, an error is raised.</p> <pre><code>from betterproto2 import unwrap\n\n# no typing error!\nunwrap(message.msg_field).field\n</code></pre>"}]}